# 4-1 Структуры памяти

## Введение

Всем привет



В четвёртой главе книги Тома Кайта "Оракл для профессионалов" речь пойдёт про структуры памяти сервера СУБД Оракл.



И мы с вами разберём три основные структуры:



Первая структура это, **Глобальная область системы** (SGA) -  используемый совместно сегмент памяти, к которому могут обращаться практически все процессы Oracle



Вторая называется **Глобальная область процесса** (PGA)-  это закрытая или можно сказать, персональная область процесса или потока, в отличии от системной области, она не доступна из других процессов или потоков.



И третья область это **Глобальная область пользователя** (UGA) - связана с конкретным сеансом. В зависимости от типа сервера, она располагается в системной области - при работе в режиме разделяемого сервера. Или в области процесса, когда оракл работает в режиме выделенного сервера.



Так же нам предлагается исследовать пять режимов управления памятью:



- Автоматическое управление памятью (AMM)

- Автоматическое управление разделяемой памятью (ASMM)

- Ручное управление разделяемой памятью

- Автоматическое управление памятью PGA

- Ручное управление памятью PGA


Тут, конечно, сразу хочется спросить: а какой из способов управления самый правильный, что нужно использовать на практике ?


Однако, как водится, не всё так однозначно.

В идеальной среде все использовали бы автоматическое управление памятью. Хотя бы потому, что это просто.

Установил всего один параметр `MEMORY_TARGERT` - и готово. Просто и эффективно.


Но временами системный администратор лучше сервера знает некоторые аспекты своей системы. А значит, он может более эффективно распределить память, а потому должен использовать менее автоматизированные способы управления.


Собственно, цель этой главы и заключается в том, чтобы узнать все аспекты памяти Оракл и научиться принимать обоснованые решения по управлению памятью сервера.  


## PGA & UGA

И начнём мы со знакомства с Глобальной областью процесса и Глобальной областью пользователя.



**PGA** это область памяти, связанная с процессом или потоком в операционной системе.



Если немного углубиться в программирование, такая область обычно выделяется с помощью таких функций языка C, как `malloc()` и `memmap()`. Размер этой области увеличивается или уменьшается в ходе работы процесса.

Область PGA никогда не залазит в системную область памяти (SGA) - она всегда распределяется только локально внутри одного потока или процесса. И это НЕ разделяемая область памяти.



Глобальная область пользователя, то есть **UGA** -  по сути отражает актуальное состояние процесса.

Текущий сеанс всегда имеет доступ к этой области памяти. А вот то, где конкретно будет выделятся эта память зависит от способа подключения к базе данных:

- В режиме разделяемого сервера  область пользователя должна хранится в структуре, к которой будет иметь доступ каждый процесс разделяемого сервера, а значит, это будет область системы SGA.

- С другой стороны, при подключении в режиме выделенного сервера отпадает нужда в доступе к состоянию сеанса из разных процессов, а значит - область UGA становится практически синонимом PGA. В этом случае она и будет содержаться внутри глобальной области процесса.


Итак, область PGA содержит память процесса и *может* включать в себя область пользователя. Остальная часть этой области обычно используется для сортировки данных, слияния индексов и прочих операций над данными.
 

В Оракле есть два способа управления той частью PGA, что не относится к области пользователя.


1. Это **ручное** управление памятью PGA, то есть, когда администратор указывает, какой объем памяти задействовать при операциях сортировки и хеширования в каждом процессе.

2. **Автоматическое** управление, при котором указывается только какой объем памяти PGA может использоваться на уровне всей системы.



В свою очередь, автоматические управление может быть реализовано одним из двух способов:

1. Используя параметр `PGA_AGGREGATE_TARGET` и указывая, какой объем памяти следует использовать на уровне экземпляра.

2. Или при помощи `MEMORY_TARGET`, определяя объема общей памяти, которую экземпляр будет использовать и для SGA и для PGA. Нужный размер области процесса в таком случае будет вычислен от этого объема автоматически.



Режимы управления памятью PGA контролируются на уровне сеанса параметром `WORKAREA_SIZE_POLICY`



## Ручное управление PGA

Для ручного управления используются три параметра:

`SORT_AREA_SIZE`, `SORT_AREA_RETAINED_SIZE`, `HASH_AREA_SIZE`

Каждый из них определяет, сколько памяти мы сервер должен использовать под те или иные операции с данными.



- `SORT_AREA_SIZE` - задаёт общий объем памяти, которая будет использоваться для сортировки данных перед их сбросом на диск

- `SORT_AREA_RETAINED_SIZE` - это память, которая будет использоваться для хранения отсортированной информации уже после окончания сортировки. Любые данные сортировки, которые не уместились в этот объем, будут записаны во временное табличное пространство.

- `HASH_AREA_SIZE` - это размер памяти, которую сервер сможет использовать для хранения хеш-таблиц. При хеш-соединении больших наборов данных меньший из двух наборов будет хешироваться в памяти, а все остальные данные, не уместившиеся в этот объем, будут сохранены во временном табличном пространстве по ключу соединения.  



В общем случае, объем памяти, равный разнице

`SORT_AREA_SIZE - SORT_AREA_RETAINED_SIZE` будет выделен в PGA, а память под хранение результатов сортировки выделится в области пользователя.



Давайте теперь перейдём от теории к практике и попробуем сами отслеживать информацию об использовании PGA  и SGA памяти в сеансе.



Изменять мы будем параметр `SORT_AREA_SIZE`, а что бы было заметнее, на что этот параметр влияет, мы будем  сортировать относительно крупную таблицу и наблюдать, как расходуется при этом память и от чего это зависит.

 

В первую очередь, конечно, подготовим такую таблицу Для этого просто создадим ей и скопируем туда данные из системной таблицы `all_objects`.



Что бы никак не влиять на тест, никаких индексов мы создавать на ней не будем, пусть сервер честно перебирает сырые данные.



Получим такую вот таблицу, назовём её T, в которой у меня получилось примерно 90 тысяч строк.

И для интереса, замерим сразу её размер. В моём случае это 12 мегабайт.  



Сразу же соберём статистику по этой таблице, что бы всё было честно, и посмотрим теперь на вот такой вот скрипт, с которым нам предлагают поэкспериментировать.

Первые его строки не очень интересны сейчас, в них открывается новое соединение с базой, выполняются некоторые настройки вывода данных, для красоты, ну и выбирается ID текущей сессии, он нам понадобится ещё в дальнейшем.



Самое главное тут в эти двух строках - мы сообщаем серверу, что намерены вручную управлять памятью PGA внутри нашей сессии и указываем, сколько памяти мы хотели бы отдать этому сеансу для сортировки данных.

Далее делаем паузу в выполнении скрипта, для того, что бы иметь возможность из другой сессии отследить текущий расход памяти.

Затем заставим сервер отсортировать нашу табличку T, после чего сделаем вторую паузу, и посмотрим, как эта сортировка повлияла на состояние области процесса.



И Прежде чем начать наши опыты, посмотрим ещё два скрипта, которые будут использоваться.

Один из них это `reset_stat.sql`, довольно простой, он пересоздаёт вспомогательную табличку `sess_stats`, в которую мы будем часто использовать сегодня и сохранять в ней статистику использования памяти. И после этого он запоминает ID сессии,  в переменную `sid`. Больше он ничего не делает.



Второй скрипт, `watch_stat.sql`, может показаться немного труднее для понимания, по крайней мере, в нём кода больше. На самом деле он выбирает из системных представлений данные о расходовании глобальной памяти, а также количество операций чтения/записи во временные табличные пространства. Ну и сохраняет эти данные в таблице `sess_stats`. При этом в запросе используется а самая переменная `sid`, в которой мы в предыдущем скрипте сохранили `id` сессии, за которой хотим следить.



В принципе, для первого примера можно было бы обойтись и без вспомогательной таблицы, но она всё равно понадобится для других в дальнейшем, так что сразу пусть будет.



Если выполнить скрипт `watch_stat`, мы увидим список интересных нам показателей по выбранной сессии.



Теперь наконец можно перейти к делу.



Давайте выполним скрипт `run_query` и посмотрим, что будет, если сделать размер области сортировки совсем маленьким, в 64 килобайта. Потом мы установим этот размер в 1 мегабайт. И, наконец, в 1 гигабайт.

Напомню, что размер таблицы у нас всего 12 мегабайт, так что гигабайта уж точно должно хватить, что бы выполнить сортировку полностью в памяти.



И так, выполняем `run_query 65536`. Сервер показывает нам, что для просмотра статистики нужно использовать номер сессии 134.  

Во втором сеансе давайте выполним сброс статистики, и посмотрим показатели использования памяти.



Можно обратить внимание, что сервер пока ни разу не обратился во временное табличное пространство, что логично, так как пока мы ещё и ничего не делали, кроме, собтвенно, подключения.



При этом Оракл выделил нам для работы 829 килобайт под память процесса и 276 килобайт под область пользователя.

Как мы знаем уже, где именно быдет выделяться область памяти пользователя зависит от типа подключения к серверу, используем мы выделенный или разделяемый сервер.

В нашем случае это будет, как видим, выделенный сервер, а это значит, что область UGA полностью лежит внутри области процесса, а значит у нас будет всего 829 килобайт памяти.



Давай теперь наконец-то выполним сортировку нашей таблицы и посмотрим, что изменится.



И изменилось многое. Во-первых, объем области памяти пользователя заметно вырос - до 596 килобайт. Для того, что бы выполнить запрос и сортировку данных, СУБД выделила нам место под область сортировки. Кроме того, ощутимо увеличилась и область PGA. А самое главное, так как сортируемые данные не уместились в 64 килобайта области сортировки, серверу пришлось использовать временные табличные пространства и проделать почти 6 тысяч операций чтения-записи. К концу работы запроса, по завершению чтения набора данных, объем PGA немного уменьшился.



Теперь проделаем все аналогичные действия, указав размер области сортировки в 1 мегабайт.



При подключении поведение сервера будет аналогично прошлому, а вот при сортировки му увидим разницу.



Объем используемой памяти UGA заметно вырос, причем его увеличение примерно равно увеличению размера области сортировки (с 64 кб до 1 мб).

Кроме того, число обращений ко временному пространству заметно снизилось.

Ну и сразу третий тест, размер области сортировки установим равным одному гигабайту.



Начальные условия у нас те же самые, что ожидаемо.



Тут легко заметить, что хоть мы и позволили серверу использовать целый гигабайт, но на практике он забрал примерно 15 мегабайт. То есть, это показывает, что параметр SORT_AREA_SIZE задаёт верхнюю границу, а не то, сколько памяти сервер зарезервирует на практике.

А главное, на этот раз всю сортировку сервер смог выполнить полностью в памяти, ни разу не обратившись ко временному пространству на дисках.



## Что важно знать про параметры `*_AREA_SIZE`  



1. эти параметры управляют максимальным размером памяти для операций сортировки-слияния данных.

2. В рамках одного запроса может выполняться несколько операций сортировки, хеширования, одновременно может быть открыто несколько курсоров, и каждая такая опеорация потребует своих областей памяти.



То есть, указав размер сортировки, к примеру, в 10 мб, сервер сможет отобрать как 10, так и 100 мегабайт ОЗУ. Эти параметры задают всего лишь верхний лимит для одиночной операции внутри сеанса.



3. И третий факт, память для этих областей выделяется по мере необходимости. Это всего лишь право серверу задействовать некоторый объем ресурсов, но не требование.



## Автоматическое управление памятью



Параметры `SORT_AREA_SIZE`, `BITMAP_AREA_SIZE`, `HASH_AREA_SIZE`, которые используются для ручного управления памятью, безусловно, решали свою задачу, и они могут использоваться и по сей день в некоторых сложных ситуациях, но у них есть очевидные недостатки.  



1. Во-первых, понять, как в действительности работают эти параметры, и каким образом будет распределяться память в конкретной системе - задача совсем не тривиальная.



2. При большом количестве пользователей, и соответственно, большом количестве одновременно выполняющихся запросов, гибко и эффективно управлять памятью практически невозможно.



И если только сисадмин не сидит в данный момент за консолью, отслеживая непрерывно размеры областей сортировки в разных сеансах и подбирая оптимальные величины параметров, все процессы в течении всего времени работы будут иметь дело с одними и теми же значения.

Однако, очевидно, что нагрузка на базу данных может довольно заметно меняться по ходу работы, а нехватка памяти, как мы на нашем тестовом примере убедились, может ощутимо влиять на число обращений к диску, а значит и на всю производительность системы.



3. Ну и третий момент, реально контролировать объем памяти, который сервер собирался использовать, было невозможно. Да, мы могли указать максимально доступный объем памяти для одной сессии, но сколько таких сессий будет запущено одновременно, точно сказать нельзя. А как следствие, можно было достаточно легко попытаться запросить памяти больше, чем её физический размер на сервере. Что так же совсем не полезно для СУБД.  



Автоматическое управление памятью появилось, в том числе, и как решение этих проблем. Оно и более простое в использовании, и позволяет эффективно, на лету, управлять размерами памяти,выделяемой в зависимости от текущей рабочей нагрузки. И в то же время лучше контролировать её расход.  



## Начнём мы с автоматического управления памятью PGA



Обычно проще всего сначала определить сколько памяти мы готовы отдать под область SGA. Это область фиксированного размера, поэтому задав его, и примерно зная, сколько памяти мы хотим оставить для работы операционной системы, можно прикинуть, сколько у нас останется под все рабочие области.  



Для управления этим процессом используются следующие параметры:



- `WORKAREA_SIZE_POLICY` - определяет, как будет распределяться память для областей сортировки и хеширования. При значении MANUAL память выделяется строго на основе соответствующих параметров. Мы только что смотрели, как это делается.



В режиме AUTO размер выделяемой памяти будет варьироваться в зависимости от объема памяти PGA, в текущий момент распределённой для экземпляра. Стандартное и рекомендуемое значение для параметра `WORKAREA_SIZE_POLICY= AUTO`



- Второй параметр называется `PGA_AGGREGATE_TARGET`. Он управляет суммарным объемом памяти, который экземпляр БД должен выделить для всех рабочих областей сортировки и хеширования данных. Это значение зависит от версии сервера и от конфигурации системы. В составе СУБД Оракл есть утилита DBCA - "помощник по настройке сервера", которая может подсказать рекомендуемое значение для этого параметра, а дальше уже администратор может отрегулировать его, подстроив при необходимости.  



Начиная с версии 11g жизнь стала ещё проще, и там достаточно вместо `PGA_AGGREGATE_TARGET` установить параметр `MEMORY_TARGET`. Он определяет общий объем памяти, доступный для областей PGA и SGA. Сервер при этом сам решит, в каких пропорция поделить эту память наиболее эффективно.



Далее мы будем считать, что у нас включено автоматическое управление памятью и параметр `PGA_AGGREGATE_TARGET > 0`



Основная цель автоматического управления памятью - это максимально эффективно использовать всю имеющуюся оперативную память сервера, но при этом не вылезти за её пределы.



Мы сейчас посмотрим на пример работы этого механизма и исследуем, как сервер меняет размеры рабочих областей в зависимости от текущей нагрузки.



Для этого, как обычно, нам потребуются несколько скриптов.



Посмотрим на `stats.sql.` Это довольно не сложный запрос, который из системных таблиц вытаскивает показатели использования памяти процесса и памяти пользователя а так же количество обращений во временные табличные пространства для текущей сессии.

И те же показатели, но для всей системы в целом. Полученные данные он сохраняет в таблицу, которая называется `sess_stats`. Причем, как мы видим, каждый раз эта таблица пересоздается при каждом запуске скрипта. Так что каждый раз мы будем получать самые актуальные данные.



Следующий скрипт, который будет использоваться, называется `single_load.sql`, он немного сложнее но, на самом деле, он всего лишь сортирует нашу таблицу T, которую мы создали в прошлом примере, а затем в цикле пробегает по всем строкам отсортированного набора данных. Причем, на первой итерации цикла запрос собирает уже знакомым нам способом статистику по использованию памяти и временных пространств и вставляет это всё в `sess_stats`. Затем вот эту вот переменную сбрасывает в значение ложь, и на всех остальных итерациях мы просто ничего не делаем. То есть, нужные нам показатели записываются только один раз.



Для эксперимента будем использовать такие вот настройки Оракла. У нас включено автоматическое управление памятью и для области PGA выделено 256 мб.  



Если очистить таблицу статистики и затем выполнить наш скрипт, мы сможем посмотреть, как сервер распорядился памятью для выполнения сортировки. Что бы чуть нагляднее было, давайте статистику всё же в девелопере посмотрим, а не через консоль.

Пока ещё не очень интересно, мы видим только, что ресурсов у нас предостаточно для того, что бы все операции проделать в памяти, к дискам обращаться ни разу не пришлось, что вполне ожидаемо. Оракл смог около 20 мегабайт отдать нашей сессии, и до ограничения в 256 мегабайт ему ещё очень далеко.



Однако, что будет, если таких сессий будет не одна, а много ? Понятно, что выделяя по 20 мегабайт на каждую, мы израсходуем всю память довольно быстро, и уже на 13-й сессии упремся в ограничение в 256 мб.  



Для эмуляции нагрузки на систему у нас есть скрипт `gen_load.sql` Он в цикле проверяет, используя системный пакет dbms_alert, не пора ли завершиться, и если сигнала остановки пока не было, ещё раз выполняет  большую сортировку.  

А вот этот вот скрипт `stop.sql`как раз останавливает выполнения процессов.



Ну и наконец, для автоматизации эмуляции нагрузки есть `run.sql`, который 12 раз запускает по 25 новых сессий с  сортировками, делая паузу по одной минуте после каждой порции процессов. Это даст нам возможность понаблюдать, как сервер будет адаптироваться под всё нарастающую нагрузку.



И если запустить `run.sql`и немножко подождать, что бы все многочисленные процессы отработали, мы накопим статистику по количеству задействованной памяти и по числу обращений ко временным пространствам.



Что бы было проще её анализировать, можно вывести результаты в таком виде. И теперь наглядно видно, как сервер пытался адаптироваться к всё возрастающей нагрузке.



Пока сеансов было немного, все сортировки выполнялись полностью в памяти, а с ростом числа сессий памяти стало не хватать, мы вышли далеко за пределы рекомендуемых 256 мегабайт, что бы это исправить оракл стал уменьшать объем выделяемой новому сеансу PGA. И в итоге этот объем упал с 20 до примерно 5 мегабайт и оставался на таком уровне уже до конца эксперимента.



При этом сервер начал активно использовать временные пространства, так как оперативной памяти для сортировки перестало хватать.



А предположим, что управление памятью шло бы в ручном режиме. Если бы мы установили `SORT_AREA_SIZE` скажем, в 5 мегабайт, каждый сеанс, с учетом, что кроме памяти для сортировки, есть и другие расходы, потреблял бы на практике около 7 мб. Отталкиваясь от этой цифры, несложно рассчитать общее потребление PGA для такого же количества сеансов сортировки.

И мы видим, что при 225 сессиях нам потребовалось бы уже 1.5 гб, и самое главное, что это значение росло бы линейно. В то же время и при малом количестве пользователей вместо сортировки в памяти всё равно довольно активно  выполнялись бы записи во временные пространства на дисках.  



## PGA_AGGREGATE_TARGET



Ещё раз вернёмся к этому параметру. Только что мы ещё раз убедились, что хоть данный параметр и используется при автоматическом управлении памятью, он не является жестким пределом и может при необходимости сильно превышаться.

То есть, экземпляр будет _стремиться_ оставаться в границах PGA_AGGREGATE_TARGET, но если это не удаётся, сервер не прекратит работу, а просто превысит этот порог.



Кроме того, рабочие области памяти, такие как область сортировки, хоть обычно и составляют крупную часть памяти PGA, но это не единственная часть.

PGA состоит из множества частей, но только рабочие области находятся под контролем экземпляра БД.

Если, к примеру, в режиме выделенного сервера, то есть, когда область пользовательских данных UGA лежит внутри PGA, выполнить код, который заполняет данными большой массив, Ораклу не останется ничего иного, кроме как разрешить это, превысив порог PGA_AGGREGATE_TARGET.



Давайте на практике сразу проверим это утверждение.



Нам предлагают создать вот такой пакет, в котором объявляется массив из строк по 2000 символов каждая.



Посмотрим теперь на статистику использования памяти.



Пока что мы ничего сложного не делали и использовали чуть меньше 4 мегабайт PGA. Кстати, надо убедиться что цель по использованию PGA по прежнему 256 мб. Ну, да, видим что это так.



Выполним теперь наш любимый запрос на сортировку.

Сервер подсказывает нам, что сортировка была выполнена полностью в памяти, и мы можем посмотреть  фактический объем потребленной памяти.



Это плюс-минус как и при прошлых наших тестах, максимум сервер задействовал 34мб.



А теперь заполним объявленный ранее массив, пусть в нём будет много строк, например вот столько.



И снова посмотрим на расход памяти. Сейчас область PGA содержит сегменты данных, которыми сам экземпляр управлять не может. В отличии от прошлого эксперимента, мы существенно превысили предел PGA_AGGREGATE_TARGET, установленный для всего экземпляра, оставаясь всего лишь в одной конкретной сессии. И поделать с этим сервер ничего не может.  



Сервер отклонил бы такой запрос только в том случае, если бы уже операционная система сообщила о нехватки памяти, и выдал бы тогда ошибку ORA-04030



`ORA-04030: out of process memory when trying to allocate`



К счастью, у нас на сервере памяти достаточно.



Тем не менее, экземпляр осведомлен о нашем хулиганстве, и если мы теперь ещё раз попробуем выполнить запрос сортировки, то уже не получим прежнего количества памяти, так как мы уже превысили целевой показатель.



И выяснится, что теперь сортировка будет выполняться на диске.  



Это показывает нам, что из-за того, что некоторая часть области PGA находится вне контроля экземпляра, выделяя крупные структуры данных в коде PL/SQL, например, используя такие огромные массивы, очень легко превысить значение PGA_AGGREGATE_TARGET, и неожиданно столкнуться с сильным падением производительности. Так как многие объединения и сортировки начнут выполняться не в памяти, а на дисках. Надо быть осторожными с такими вещами.  

Ну и надо помнить, что параметр PGA_AGGREGATE_TARGET это скорее просьба, но ни в коем случае не ограничение.



## Ручное vs Автоматическое управление памятью



Прежде, чем говорить о том, какой вариант следует или не следует использовать, надо сделать небольшое но очень важное предупреждение:  



>не вносите никаких изменений на реальной системе без предварительного тестирования.



К примеру, обнаружив, что на вашем сервере используется ручное управление памятью и заменив его автоматическим, вполне реально получить любой из трех эффектов:



- Производительность не изменится никак

- Производительность увеличится

- Производительность существенно уменьшится



Теперь, из всего сказанного выше понятно, что основная трудность в ручном управлении это правильно подобрать размеры областей, то есть значения для `sort/hash_area_size`



Установив эти значения маленькими, мы получим приемлемую производительность при большом количестве пользователей, но при снижении нагрузки на систему большой объем памяти просто останется не задействован и сервер будет работать заметно медленнее, чем мог бы.  



Использование автоматического управления позволяет динамически подстраиваться под текущую нагрузку и достигать оптимальной производительности.  



Однако бывают и ситуации, когда ручное управление памятью предпочтительнее. Например, если требуется выполнить какой-то тяжелый запрос в тот момент времени, когда общая нагрузка на систему минимальна. Скажем ночью, когда практически нет других пользователей. В этом случае имеет смысл через `alter session` отключить автоматическое управление и отдать запросу все имеющиеся на сервере ресурсы, так как мы знаем, что наш запрос всё равно единственный в это время.  



То есть, ручное управление вполне разумно использовать при автоматическом запуске больших пакетных заданий в определенное время, а автоматическое для повседневной работы системы.



## ИТОГО

Итак, мы рассмотрели две структуры памяти - UGA и PGA

В области PGA хранятся различные структуры данных, которые не должны зависеть от текущей сессии и доступ к которым есть только у текущего процесса.



Область UGA хранит данные, специфические для данной сессии. Эта область будет частью PGA для выделенного сервера или будет выделяться из системной области, при работе в режиме разделяемого сервера.

 

Отсюда следует, что область SGA в режиме разделяемого сервера должна быть существенно больше, чем для выделенного.  



В следующей части мы подробно посмотрим, что ещё может хранить и как устроена системная глобальная область, а на сегодня пока всё, до встречи.